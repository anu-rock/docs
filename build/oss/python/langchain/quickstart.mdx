---
title: Quickstart
---

import AlphaCallout from '/snippets/alpha-lc-callout.mdx';

<AlphaCallout />

This quickstart will take you from zero to a fully functional AI agent in just a few minutes. You will start simple and gradually build up to a more sophisticated agent.

## Installation

<CodeGroup>
    ```bash pip
    pip install --pre -U "langchain[anthropic]"
    ```

    ```bash uv
    uv add --prerelease=allow "langchain[anthropic]"
    ```
</CodeGroup>




## Build a basic agent

Let's begin with agent basics - creating a simple agent that can answer questions and use tools. Create an agent with the following characteristics:

- A language model (Claude 3.7 Sonnet)
- A simple tool (weather function)
- A basic prompt
- The ability to invoke it with messages

```python
from langchain.agents import create_agent

def get_weather(city: str) -> str:
    """Get weather for a given city."""
    return f"It's always sunny in {city}!"

agent = create_agent(
    model="anthropic:claude-3-7-sonnet-latest",
    tools=[get_weather],
    prompt="You are a helpful assistant",
)

# Run the agent
agent.invoke(
    {"messages": [{"role": "user", "content": "what is the weather in sf"}]}
)
```




## Build a real-world agent

Now let's create something more practical. Let's build a weather forecasting agent that demonstrates the key concepts you would use in production:

1. **Detailed system prompts** for better agent behavior
2. **Real-world tools** that integrate with external data
3. **Model configuration** for consistent responses
4. **Structured output** for predictable results
5. **Conversational memory** for chat-like interactions
6. **Bring it all together** to create a fully functional agent

Let's walk through each step:

<Steps>
    <Step title="Define the system prompt">
        The system prompt is your agent's personality and instructions. Make it
        specific and actionable:

        ```python wrap
        system_prompt = """You are an expert weather forecaster, who speaks in puns.

        You have access to two tools:

        - get_weather_for_location: use this to get the weather for a specific location
        - get_user_location: use this to get the user's location

        If a user asks you for the weather, make sure you know the location. If you can tell from the question that they mean wherever they are, use the get_user_location tool to find their location."""
        ```



    </Step>
    <Step title="Create tools">
        [Tools](/oss/python/langchain/tools) are functions your agent can call. They should be well-documented. Oftentimes, tools will want to connect to external systems, and will rely on runtime configuration to do so. Notice here how the `get_user_location` tool does exactly that:

        ```python
        from langchain.tools import tool
        from dataclasses import dataclass
        from langgraph.runtime import get_runtime

        @dataclass
        class Context:
            user_id: str

        def get_weather_for_location(city: str) -> str:
            """Get weather for a given city."""
            return f"It's always sunny in {city}!"

        @tool
        def get_user_location() -> str:
            """Retrieve user information based on user ID."""
            runtime = get_runtime(Context)
            user_id = runtime.context.user_id
            return "Florida" if user_id == "1" else "SF"
        ```



    </Step>
    <Step title="Configure your model">
        Set up your language model with the right parameters for your use case:

        ```python
        from langchain.chat_models import init_chat_model

        model = init_chat_model(
            "anthropic:claude-3-7-sonnet-latest",
            temperature=0
        )
        ```



    </Step>
    <Step title="Define response format">
        Structured outputs ensure your agent returns data in a predictable
        format. Here, we use Python's [`DataClass`](https://docs.python.org/3/library/dataclasses.html)
        dictionary.

        ```python
        from dataclasses import dataclass

        @dataclass
        class WeatherResponse:
            conditions: str
            punny_response: str
        ```



    </Step>
    <Step title="Add memory">
        Enable your agent to remember conversation history:

        ```python
        from langgraph.checkpoint.memory import InMemorySaver

        checkpointer = InMemorySaver()
        ```



    </Step>
    <Step title="Run the agent">
        Now assemble your agent with all the components:

        ```python
        agent = create_agent(
            model=model,
            prompt=system_prompt,
            tools=[get_user_location, get_weather_for_location],
            context_schema=Context,
            response_format=WeatherResponse,
            checkpointer=checkpointer
        )

        config = {"configurable": {"thread_id": "1"}}
        response = agent.invoke(
            {"messages": [{"role": "user", "content": "what is the weather outside?"}]},
            config=config,
            context=Context(user_id="1")
        )

        response['structured_response']

        response = agent.invoke(
            {"messages": [{"role": "user", "content": "thank you!"}]},
            config=config,
            context=Context(user_id="1")
        )

        response['structured_response']
        ```

        <Expandable title="Bring it all together">
        ```python
        from dataclasses import dataclass

        from langchain.agents import create_agent
        from langchain.chat_models import init_chat_model
        from langchain.tools import tool
        from langgraph.checkpoint.memory import InMemorySaver
        from langgraph.runtime import get_runtime

        # Define system prompt
        system_prompt = """You are an expert weather forecaster, who speaks in puns.

        You have access to two tools:

        - get_weather_for_location: use this to get the weather for a specific location
        - get_user_location: use this to get the user's location

        If a user asks you for the weather, make sure you know the location. If you can tell from the question that they mean wherever they are, use the get_user_location tool to find their location."""

        # Define context schema
        @dataclass
        class Context:
            user_id: str

        # Define tools
        def get_weather_for_location(city: str) -> str:
            """Get weather for a given city."""
            return f"It's always sunny in {city}!"

        @tool
        def get_user_location() -> str:
            """Retrieve user information based on user ID."""
            runtime = get_runtime(Context)
            user_id = runtime.context.user_id
            return "Florida" if user_id == "1" else "SF"

        # Configure model
        model = init_chat_model(
            "anthropic:claude-3-7-sonnet-latest",
            temperature=0
        )

        # Define response format
        @dataclass
        class WeatherResponse:
            conditions: str
            punny_response: str

        # Set up memory
        checkpointer = InMemorySaver()

        # Create agent
        agent = create_agent(
            model=model,
            prompt=system_prompt,
            tools=[get_user_location, get_weather_for_location],
            context_schema=Context,
            response_format=WeatherResponse,
            checkpointer=checkpointer
        )

        # Run agent
        config = {"configurable": {"thread_id": "1"}}

        response = agent.invoke(
            {"messages": [{"role": "user", "content": "what is the weather outside?"}]},
            config=config,
            context=Context(user_id="1")
        )
        print(response['structured_response'])

        response = agent.invoke(
            {"messages": [{"role": "user", "content": "thank you!"}]},
            config=config,
            context=Context(user_id="1")
        )
        print(response['structured_response'])
        ```
        </Expandable>



    </Step>
</Steps>

Congratulations! You now have a sophisticated AI agent that can:

- **Understand context** and remember conversations
- **Use multiple tools** intelligently
- **Provide structured responses** in a consistent format
- **Handle user-specific information** through context
- **Maintain conversation state** across interactions
